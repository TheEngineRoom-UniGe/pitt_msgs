// Generated by gencpp from file pitt_msgs/SupportSegmentationRequest.msg
// DO NOT EDIT!


#ifndef PITT_MSGS_MESSAGE_SUPPORTSEGMENTATIONREQUEST_H
#define PITT_MSGS_MESSAGE_SUPPORTSEGMENTATIONREQUEST_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <sensor_msgs/PointCloud2.h>
#include <sensor_msgs/PointCloud2.h>

namespace pitt_msgs
{
template <class ContainerAllocator>
struct SupportSegmentationRequest_
{
  typedef SupportSegmentationRequest_<ContainerAllocator> Type;

  SupportSegmentationRequest_()
    : header()
    , input_cloud()
    , input_norm()
    , min_iterative_cloud_percentual_size(0.0)
    , min_iterative_plane_percentual_size(0.0)
    , horizontal_axis()
    , variance_threshold_for_horizontal(0.0)
    , support_edge_remove_offset()
    , ransac_max_iteration_threshold(0)
    , ransac_distance_point_in_shape_threshold(0.0)
    , ransac_model_normal_distance_weigth(0.0)  {
    }
  SupportSegmentationRequest_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , input_cloud(_alloc)
    , input_norm(_alloc)
    , min_iterative_cloud_percentual_size(0.0)
    , min_iterative_plane_percentual_size(0.0)
    , horizontal_axis(_alloc)
    , variance_threshold_for_horizontal(0.0)
    , support_edge_remove_offset(_alloc)
    , ransac_max_iteration_threshold(0)
    , ransac_distance_point_in_shape_threshold(0.0)
    , ransac_model_normal_distance_weigth(0.0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef  ::sensor_msgs::PointCloud2_<ContainerAllocator>  _input_cloud_type;
  _input_cloud_type input_cloud;

   typedef  ::sensor_msgs::PointCloud2_<ContainerAllocator>  _input_norm_type;
  _input_norm_type input_norm;

   typedef float _min_iterative_cloud_percentual_size_type;
  _min_iterative_cloud_percentual_size_type min_iterative_cloud_percentual_size;

   typedef float _min_iterative_plane_percentual_size_type;
  _min_iterative_plane_percentual_size_type min_iterative_plane_percentual_size;

   typedef std::vector<float, typename ContainerAllocator::template rebind<float>::other >  _horizontal_axis_type;
  _horizontal_axis_type horizontal_axis;

   typedef float _variance_threshold_for_horizontal_type;
  _variance_threshold_for_horizontal_type variance_threshold_for_horizontal;

   typedef std::vector<float, typename ContainerAllocator::template rebind<float>::other >  _support_edge_remove_offset_type;
  _support_edge_remove_offset_type support_edge_remove_offset;

   typedef int32_t _ransac_max_iteration_threshold_type;
  _ransac_max_iteration_threshold_type ransac_max_iteration_threshold;

   typedef float _ransac_distance_point_in_shape_threshold_type;
  _ransac_distance_point_in_shape_threshold_type ransac_distance_point_in_shape_threshold;

   typedef float _ransac_model_normal_distance_weigth_type;
  _ransac_model_normal_distance_weigth_type ransac_model_normal_distance_weigth;




  typedef boost::shared_ptr< ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator> const> ConstPtr;

}; // struct SupportSegmentationRequest_

typedef ::pitt_msgs::SupportSegmentationRequest_<std::allocator<void> > SupportSegmentationRequest;

typedef boost::shared_ptr< ::pitt_msgs::SupportSegmentationRequest > SupportSegmentationRequestPtr;
typedef boost::shared_ptr< ::pitt_msgs::SupportSegmentationRequest const> SupportSegmentationRequestConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace pitt_msgs

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'sensor_msgs': ['/opt/ros/indigo/share/sensor_msgs/cmake/../msg'], 'pcl_msgs': ['/opt/ros/indigo/share/pcl_msgs/cmake/../msg'], 'std_msgs': ['/opt/ros/indigo/share/std_msgs/cmake/../msg'], 'geometry_msgs': ['/opt/ros/indigo/share/geometry_msgs/cmake/../msg'], 'pitt_msgs': ['/home/carlotta/catkin_ws/src/pitt_msgs/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "684c9741c35cbee4073943a17c5104cb";
  }

  static const char* value(const ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x684c9741c35cbee4ULL;
  static const uint64_t static_value2 = 0x073943a17c5104cbULL;
};

template<class ContainerAllocator>
struct DataType< ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "pitt_msgs/SupportSegmentationRequest";
  }

  static const char* value(const ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
sensor_msgs/PointCloud2 	input_cloud\n\
sensor_msgs/PointCloud2 	input_norm\n\
\n\
\n\
float32 	min_iterative_cloud_percentual_size\n\
float32 	min_iterative_plane_percentual_size\n\
float32[] 	horizontal_axis\n\
float32 	variance_threshold_for_horizontal\n\
float32[] 	support_edge_remove_offset\n\
\n\
int32 	ransac_max_iteration_threshold\n\
float32 	ransac_distance_point_in_shape_threshold\n\
float32 	ransac_model_normal_distance_weigth\n\
\n\
\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
\n\
================================================================================\n\
MSG: sensor_msgs/PointCloud2\n\
# This message holds a collection of N-dimensional points, which may\n\
# contain additional information such as normals, intensity, etc. The\n\
# point data is stored as a binary blob, its layout described by the\n\
# contents of the \"fields\" array.\n\
\n\
# The point cloud data may be organized 2d (image-like) or 1d\n\
# (unordered). Point clouds organized as 2d images may be produced by\n\
# camera depth sensors such as stereo or time-of-flight.\n\
\n\
# Time of sensor data acquisition, and the coordinate frame ID (for 3d\n\
# points).\n\
Header header\n\
\n\
# 2D structure of the point cloud. If the cloud is unordered, height is\n\
# 1 and width is the length of the point cloud.\n\
uint32 height\n\
uint32 width\n\
\n\
# Describes the channels and their layout in the binary data blob.\n\
PointField[] fields\n\
\n\
bool    is_bigendian # Is this data bigendian?\n\
uint32  point_step   # Length of a point in bytes\n\
uint32  row_step     # Length of a row in bytes\n\
uint8[] data         # Actual point data, size is (row_step*height)\n\
\n\
bool is_dense        # True if there are no invalid points\n\
\n\
================================================================================\n\
MSG: sensor_msgs/PointField\n\
# This message holds the description of one point entry in the\n\
# PointCloud2 message format.\n\
uint8 INT8    = 1\n\
uint8 UINT8   = 2\n\
uint8 INT16   = 3\n\
uint8 UINT16  = 4\n\
uint8 INT32   = 5\n\
uint8 UINT32  = 6\n\
uint8 FLOAT32 = 7\n\
uint8 FLOAT64 = 8\n\
\n\
string name      # Name of field\n\
uint32 offset    # Offset from start of point struct\n\
uint8  datatype  # Datatype enumeration, see above\n\
uint32 count     # How many elements in the field\n\
";
  }

  static const char* value(const ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.input_cloud);
      stream.next(m.input_norm);
      stream.next(m.min_iterative_cloud_percentual_size);
      stream.next(m.min_iterative_plane_percentual_size);
      stream.next(m.horizontal_axis);
      stream.next(m.variance_threshold_for_horizontal);
      stream.next(m.support_edge_remove_offset);
      stream.next(m.ransac_max_iteration_threshold);
      stream.next(m.ransac_distance_point_in_shape_threshold);
      stream.next(m.ransac_model_normal_distance_weigth);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct SupportSegmentationRequest_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::pitt_msgs::SupportSegmentationRequest_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "input_cloud: ";
    s << std::endl;
    Printer< ::sensor_msgs::PointCloud2_<ContainerAllocator> >::stream(s, indent + "  ", v.input_cloud);
    s << indent << "input_norm: ";
    s << std::endl;
    Printer< ::sensor_msgs::PointCloud2_<ContainerAllocator> >::stream(s, indent + "  ", v.input_norm);
    s << indent << "min_iterative_cloud_percentual_size: ";
    Printer<float>::stream(s, indent + "  ", v.min_iterative_cloud_percentual_size);
    s << indent << "min_iterative_plane_percentual_size: ";
    Printer<float>::stream(s, indent + "  ", v.min_iterative_plane_percentual_size);
    s << indent << "horizontal_axis[]" << std::endl;
    for (size_t i = 0; i < v.horizontal_axis.size(); ++i)
    {
      s << indent << "  horizontal_axis[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.horizontal_axis[i]);
    }
    s << indent << "variance_threshold_for_horizontal: ";
    Printer<float>::stream(s, indent + "  ", v.variance_threshold_for_horizontal);
    s << indent << "support_edge_remove_offset[]" << std::endl;
    for (size_t i = 0; i < v.support_edge_remove_offset.size(); ++i)
    {
      s << indent << "  support_edge_remove_offset[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.support_edge_remove_offset[i]);
    }
    s << indent << "ransac_max_iteration_threshold: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ransac_max_iteration_threshold);
    s << indent << "ransac_distance_point_in_shape_threshold: ";
    Printer<float>::stream(s, indent + "  ", v.ransac_distance_point_in_shape_threshold);
    s << indent << "ransac_model_normal_distance_weigth: ";
    Printer<float>::stream(s, indent + "  ", v.ransac_model_normal_distance_weigth);
  }
};

} // namespace message_operations
} // namespace ros

#endif // PITT_MSGS_MESSAGE_SUPPORTSEGMENTATIONREQUEST_H
